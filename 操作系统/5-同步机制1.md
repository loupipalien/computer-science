## 同步机制1
### 目录

### 进程的并发执行
从进程的特征出发
- 并发
  - 进程的执行是间断性的
  - 进程的相对执行速度是不可预测的
- 共享
  - 进程/线程之间的制约性
- 不确定性
  - 进程执行的结果与其执行的相对速度有关, 是不确定的

### 进程互斥
- 竞争条件 (Race Condition): 两个或多个进程读写某些共享数据, 而最后的结果取决于进程运行的精确时序
- 进程互斥 (Mutual Exclusive): 由于各进程要求使用共享资源 (变量, 文件等), 而这些资源需要排他性使用, 各进程之间竞争使用这些资源的关系称为进程互斥
- 临界资源 (Critical Resource): 系统中某些资源一次只允许一个进程使用, 称这样的资源为临界资源或互斥资源或共享变量
- 临界区 (Critical Section): 各进程中对某个临界资源 (共享变量) 实施操作的代码片段
#### 临界区的使用原则
- 没有进程在临界区时, 想进入的临界区的进程可进入
- 不允许两个进程同时处于其临界区中
- 临界区外运行的进程不得阻塞其他进程进入临界区
- 不得使进程无限期等待进入临界区
#### 实现进程互斥的方案
- 软件方案: Dekker 解法, Peterson 解法
- 硬件方案: 屏蔽中断, TSL(XCHG) 指令

### 进程互质的软件解决方案
#### 软件解决方案
- DEKKER 算法
  - P 进程
  ```
  ...
  pturn = true;
  while (qturn) {
    // 两个进程都想执行的情况下, turn 为 2 让 Q 进程执行, P 进程等待
    if (turn == 2) {
        pturn = false;
        // 忙等待
        while (turn == 2);
        pturn = true;
    }
  }

  // 临界区
  ...

  turn = 2;
  pturn = false;
  ...
  ```
  - Q 进程
  ```
  ...
  qturn = true;
  while (pturn) {
    // 两个进程都想执行的情况下, turn 为 1 让 P 进程执行, Q 进程等待
    if (turn == 1) {
      qturn = false;
      // 忙等待
      while (turn == 1);
      qturn = true;
    }
  }

  // 临界区
  ...

  turn = 1;
  qturn = false;
  ...
  ```
- PETERSON 算法
解决了互斥访问的问题, 而且克服了强制轮流法的缺点, 可以完全正常的工作
  ```
  进程 i:
      ...
      enter_region(i);
      // 临界区
      ...
      leave_region(i);
      ...
  ```
  - enter_region
  ```
  #define FALSE 0
  #define TRUE 1
  // 进程个数
  #define N 2
  // 轮到谁
  int turn;
  // 进程兴趣组, 初始值都为 FALSE
  int int interested[N];

  void enter_region (int process) {
    // 另一个进程的进程号
    int other;
    // 由于只有两个进程, 一个进程号是 0, 一个进程号是 1
    other = 1 - process;
    // 表明本进程感兴趣
    interested[process] = TRUE;
    // 设置标志位
    turn = process;
    // 这里比较妙
    while (trun == process && interested[other] == TRUE);
  }
  ```
  - leave_region
  ```
  void leave_region (int process) {
    // 进程离开临界区
    interested[process] = FALSE;
  }
  ```
#### 硬件解决方案
- 中断屏蔽方法
```

```

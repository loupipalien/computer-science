## 串
### 目录

### 定义与术语
定义: 由来自字母表 $\Sigma$ 的字符所组成的**有限序列**
$$ S = a_0, a_1, a_2, ... , a_{n-1} \in \Sigma^\ast $$

术语:
- 相等: S[0, n) = T[0, m), 长度相等 (n = m), 且对应的字符均相同 (S[i] = T[i])
- 子串: S.substr(i, k) = S[i, i + k), 0 <= i <= n, 0 <= k; 即从 S[i] 起的连续 k 个字符
- 前缀: S.prefix(k) = S.substr(0, k) = S[0, k), 0 <= k <= n; 即 S 中最靠前的 k 个字符
- 后缀: S.suffix(k) = S.substr(n - k, k) = S[n - k, n), 0 <= k <= n; 即 S 中最靠后的 k 个字符
- 联系: S.substr(i, k) = S.prefix(i + k).suffix(k)
- 空串: S[0, n = 0), 也是任何串的子串, 前缀, 后缀

### ADT
|接口|说明|
|-|-|
|length()|返回串的长度|
|charAt(i)|返回串中第 i 个字符|
|substr(i, k)|返回串中第 i 个字符到第 k 个字符的子串, i 闭 k 开|
|prefix(k)|返回串中前 k 个字符的子串|
|suffix(k)|返回串中后 k 个字符的子串|
|concat(T)|将串 T 连接在原串之后|
|equal(T)|判定 T 是否与原串相等|
|indexOf(P)|返回原串中第一个子串 P 的起始下标|

### 串匹配
记文本串为 T, 模式串为 P; n = |T| 和 m = |P|, 通常有 n >> m >> 2
模式匹配(Pattern Matching):
- detection: P 是否出现
- location: 首次在哪里出现
- counting: 共出现几次
- enumeration: 各出现在哪里

### 算法评测
- 随机 T + 随机 P ? 不妥!
以 $\Sigma = \lbrace 0, 1 \rbrace^\ast$ 为例, | {长度为 m 的 P} | = $2^m$, | {长度为 m 且在 T 中出现的 P} | = n - m + 1 < n
匹配成功的概率 = n / $2^m$ << 100000 / $2^100$ < $2^{-25}$,如此无法对算法做充分的测试
- 随机 T, 对成功或失败的匹配分别测试
成功: 在 T 中, 随机取出长度为 m 的子串作为 P; 分析平均复杂度
失败: 采用随机的 P; 统计平均复杂度

### 蛮力匹配算法
思想: 自左向右以字符为单位, 依次移动模式串, 指导在某个位置发现匹配  
蛮力匹配算法实现:  
- 版本一
```
int match(char * P, char * T) {
    int n = (int) strlen(T), i = 0; //文本串指针
    int m = (int) strlen(P), j = 0; //模式串指针
    while(j < m && i < n) {
      if(T[i] == P[j]) {
        i++; j++; //若匹配则携手共进
      } else {
        j = 0; i = i - j + 1; // 不匹配则P复位, T回退
      }
    }
    return i - j;// 当i = n, j < m 时返回值大于n - m则意味着匹配失败
}
```
- 版本二
```
int match(char * P, char * T) {
    int n = (int) strlen(T), i = 0; // T[i]与P[0]对齐
    int m = (int) strlen(P), j; //T[i + j]与P[j]对齐
    for(i = 0; i < n - m + 1; i++) {
      for(j = 0; j < m; j++) {
        if(T[i + j] != P[j]) break; // 若失配则P整体右移一个字符
      }
      if(m <= j) break; // 找到匹配子串
    }
    return i; // 返回值大于n - m则意味着匹配失败
}
```
复杂度:
- 最好情况: 只经过依次比对即可确定匹配; 比对 m 次, 复杂度为 O(m)
- 最坏情况: 每轮比对至 P 的末字符, 且反复如此; 比对 m * (n - m + 1), 因为一般地有 m << n, 故复杂度为 O(n * m)
注意: $| \Sigma |$ 越小, 最坏情况出现的概率越高; m 越大, 最坏情况的后果更加严重; 当 $| \Sigma |$ 越大, 匹配复杂度越可能降至 O(n)

### KMP 算法
**蛮力算法低效原因:** 当 T[i] 与 P[j] 失配时, T 回退 P复位之后, 此前 T[i] 中比对匹配的字符将再次参与比对  
**失配时但有局部匹配成功:** 当 T[i] 与 P[j] 失配时, 我们已经掌握了 T[i - j, i) 的信息, 即 T[i - j, i) = P[0, j)  
**失配时的局部匹配可为后续匹配利用:** 当 T[i] 与 P[j] 失配时, 找到 P[0, j) 子串中最大自匹配的真前缀和真后缀, 记为 P[0,t) = P[j-t,j), 匹配串 P 向前滑动 j - t 个字符, 重置 j = t 并开始下一轮比对, 继续从比较 T[i] 和 P[j]  
**当 T[i] 与 P[j] 失配时如何找到 t 值:** 因为 t 为 P[0, j) 串中最大自匹配的真前缀和真后缀的长度, 即 t 是关于 j 为自变量的函数, t 的值仅与匹配串 P 有关, 那么在匹配之前即可计算出 t = next(j)  
**最长自匹配 = 快速右移 + 避免回溯:** 对于任意 j, N(P, j) = {0 <= t < j | P[0, t) = P[j-t, j)}, 即 t = next(j) = max(N(P, j)); 当 j = 0, 即 N(P, j) = $\emptyset$, t = next(j) = -1;  
**构造 next 表:**  
**KMP算法实现:**  
```
int match(char * P, char * T) {
    int * next = buildNext(P); //根据匹配串构造next表
    int n = (int) strlen(T), i = 0; //文本串指针
    int m = (int) strlen(P), j = 0; //模式串指针
    while(j < m && i < n) {
      if(0 > j || T[i] == P[j]) {
        i++; j++; //若匹配则携手共进
      } else {
        j = next[j]; // 不匹配则P右移, T不回退
      }
    }
    delete [] next; // 释放next表
    return i - j;
}
```
### KMP 算法改进

### other
D.E.Knuth, J.H.Morris, V.R.Pratt

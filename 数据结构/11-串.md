## 串
### 目录

### 定义与术语
定义: 由来自字母表 $\Sigma$ 的字符所组成的**有限序列**
$$ S = a_0, a_1, a_2, ... , a_{n-1} \in \Sigma^\ast $$

术语:
- 相等: S[0, n) = T[0, m), 长度相等 (n = m), 且对应的字符均相同 (S[i] = T[i])
- 子串: S.substr(i, k) = S[i, i + k), 0 <= i <= n, 0 <= k; 即从 S[i] 起的连续 k 个字符
- 前缀: S.prefix(k) = S.substr(0, k) = S[0, k), 0 <= k <= n; 即 S 中最靠前的 k 个字符
- 后缀: S.suffix(k) = S.substr(n - k, k) = S[n - k, n), 0 <= k <= n; 即 S 中最靠后的 k 个字符
- 联系: S.substr(i, k) = S.prefix(i + k).suffix(k)
- 空串: S[0, n = 0), 也是任何串的子串, 前缀, 后缀

### ADT
|接口|说明|
|-|-|
|length()|返回串的长度|
|charAt(i)|返回串中第 i 个字符|
|substr(i, k)|返回串中第 i 个字符到第 k 个字符的子串, i 闭 k 开|
|prefix(k)|返回串中前 k 个字符的子串|
|suffix(k)|返回串中后 k 个字符的子串|
|concat(T)|将串 T 连接在原串之后|
|equal(T)|判定 T 是否与原串相等|
|indexOf(P)|返回原串中第一个子串 P 的起始下标|

### 串匹配
记文本串为 T, 模式串为 P; n = |T| 和 m = |P|, 通常有 n >> m >> 2
模式匹配(Pattern Matching):
- detection: P 是否出现
- location: 首次在哪里出现
- counting: 共出现几次
- enumeration: 各出现在哪里

### 算法评测
- 随机 T + 随机 P ? 不妥!
以 $ \Sigma = \lbrace 0, 1 \rbrace^\ast $ 为例, | {长度为 m 的 P} | = $ 2^m $, | {长度为 m 且在 T 中出现的 P} | = n - m + 1 < n
匹配成功的概率 = n / $ 2^m $ << 100000 / $ 2^100 $ < $ 2^{-25} $,如此无法对算法做充分的测试
- 随机 T, 对成功或失败的匹配分别测试
成功: 在 T 中, 随机取出长度为 m 的子串作为 P; 分析平均复杂度
失败: 采用随机的 P; 统计平均复杂度

### 蛮力匹配算法
思想: 自左向右以字符为单位, 依次移动模式串, 指导在某个位置发现匹配  
版本一实现;  
版本二实现;  
复杂度:
- 最好情况: 只经过依次比对即可确定匹配; 比对 m 次, 复杂度为 O(m)
- 最坏情况: 每轮比对至 P 的末字符, 且反复如此; 比对 m * (n - m + 1), 因为一般地有 m << n, 故复杂度为 O(n * m)
注意: $ | \Sigma| $ 越小, 最坏情况出现的概率越高; m 越大, 最坏情况的后果更加严重; 当 $ | \Sigma| $ 越大, 匹配复杂度越可能降至 O(n)

### KMP 算法

### KMP 算法改进
